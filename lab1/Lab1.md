<p align="center"><b>МОНУ НТУУ КПІ ім. Ігоря Сікорського ФПМ СПіСКС</b></p> <p align="center"> <b>Звіт з лабораторної роботи 1</b><br/> "Обробка списків з використанням базових функцій"<br/> дисципліни "Вступ до функціонального програмування" </p> <p align="right"><b>Студент</b>: Атанов Назар Данилович КВ-23</p> <p align="right"><b>Рік</b>: 2025</p>

## Загальне завдання

Загальне завдання складається з восьми пунктів, які демонструють базові операції зі списками в Common Lisp.

### Пункт 1: Створення списку.  

Створюємо список з п'яти елементів, використовуючи функції `LIST` і `CONS`. Список повинен містити:

- хоча б один символ
- хоча б одне число
- хоча б один непустий підсписок
- хоча б один пустий підсписок

```lisp
[1]> (setq my-list 
       (cons 'hello 
             (cons 42 
                   (cons (list 'a 'b) 
                         (cons nil 
                               (cons (list 1 2 3) nil))))))
(HELLO 42 (A B) NIL (1 2 3))
```

**Пояснення:** Використовуємо `CONS` для послідовного додавання елементів, а `LIST` для створення підсписків. Результат містить символ `HELLO`, число `42`, непустий підсписок `(A B)`, пустий підсписок `NIL`, та ще один підсписок `(1 2 3)`.

### Пункт 2: Отримання голови списку

```lisp
[2]> (car my-list)
HELLO
```

Функція `CAR` повертає перший елемент списку (голову).

### Пункт 3: Отримання хвоста списку

```lisp
[3]> (cdr my-list)
(42 (A B) NIL (1 2 3))
```

Функція `CDR` повертає список без першого елемента (хвіст).

### Пункт 4: Отримання третього елемента

```lisp
[4]> (car (cdr (cdr my-list)))
(A B)

[5]> (third my-list)
(A B)
```

Третій елемент можна отримати через композицію `CAR` і `CDR` або використати стандартну функцію `THIRD`.

### Пункт 5: Отримання останнього елемента

```lisp
[6]> (car (last my-list))
(1 2 3)
```

Функція `LAST` повертає останній cons-елемент списку, а `CAR` витягує з нього значення.

### Пункт 6: Використання предикатів ATOM та LISTP

#### Предикат ATOM

Перевіряє, чи є елемент атомом (не списком):

```lisp
[7]> (atom (car my-list))
T

[8]> (atom (third my-list))
NIL

[9]> (atom (second my-list))
T
```

Результати:

- `HELLO` є атомом → `T`
- `(A B)` не є атомом (це список) → `NIL`
- `42` є атомом → `T`

#### Предикат LISTP

Перевіряє, чи є елемент списком:

```lisp
[10]> (listp (third my-list))
T

[11]> (listp (car my-list))
NIL

[12]> (listp (car (last my-list)))
T
```

Результати:

- `(A B)` є списком → `T`
- `HELLO` не є списком → `NIL`
- `(1 2 3)` є списком → `T`

### Пункт 7: Використання інших предикатів

#### Предикат NUMBERP

Перевіряє, чи є елемент числом:

```lisp
[13]> (numberp (second my-list))
T

[14]> (numberp (car my-list))
NIL
```

Результати:

- `42` є числом → `T`
- `HELLO` не є числом → `NIL`

#### Предикат SYMBOLP

Перевіряє, чи є елемент символом:

```lisp
[15]> (symbolp (car my-list))
T

[16]> (symbolp (second my-list))
NIL
```

Результати:

- `HELLO` є символом → `T`
- `42` не є символом → `NIL`

#### Предикат NULL

Перевіряє, чи є елемент `NIL`:

```lisp
[17]> (null (fourth my-list))
T

[18]> (null (car my-list))
NIL
```

Результати:

- Четвертий елемент є `NIL` → `T`
- `HELLO` не є `NIL` → `NIL`

### Пункт 8: Об'єднання списків

```lisp
[19]> (append my-list (third my-list))
(HELLO 42 (A B) NIL (1 2 3) A B)
```

Функція `APPEND` об'єднує основний список з його третім елементом `(A B)`. Елементи підсписку `A` і `B` додаються до кінця результуючого списку.

## Варіант 2

Структура списку для варіанту 2:

![[Pasted image 20251116235344.png]]

Список має наступну структуру:

- Перший елемент: підсписок `(D (E 5))`
- Другий елемент: символ `B`
- Третій елемент: підсписок `(A)`
- Четвертий елемент: символ `C`

### Створення списку

```lisp
[20]> (setq variant-list
        (list (list 'd (list 'e 5))
              'b
              (list 'a)
              'c))
((D (E 5)) B (A) C)
```

**Пояснення:** Використовуємо одну форму `LIST` на верхньому рівні. Перший аргумент створюється через вкладений виклик `(list 'd (list 'e 5))`, який формує структуру `(D (E 5))`. Третій аргумент створюється через `(list 'a)`, що дає `(A)`.

### Перевірка структури списку

Перевіряємо, що список створено правильно:

```lisp
[21]> (car variant-list)
(D (E 5))

[22]> (second variant-list)
B

[23]> (third variant-list)
(A)

[24]> (fourth variant-list)
C
```

Перевіряємо вкладену структуру першого елемента:

```lisp
[25]> (car (car variant-list))
D

[26]> (second (car variant-list))
(E 5)

[27]> (car (second (car variant-list)))
E

[28]> (second (second (car variant-list)))
5
```

Перевіряємо структуру третього елемента:

```lisp
[29]> (car (third variant-list))
A
```

Усі перевірки підтверджують, що список створено відповідно до структури варіанту 2.

## Висновки

У ході виконання лабораторної роботи було:

1. Створено список з п'яти елементів, використовуючи функції `CONS` і `LIST`
2. Опрацьовано базові функції для роботи зі списками: `CAR`, `CDR`, `LAST`, `APPEND`
3. Використано предикати для перевірки типів даних: `ATOM`, `LISTP`, `NUMBERP`, `SYMBOLP`, `NULL`
4. Створено список складної структури відповідно до варіанту завдання
5. Отримано практичні навички роботи з Common Lisp та REPL

Всі завдання виконано успішно, результати відповідають очікуваним значенням.